#!/usr/bin/env python3
"""
LangChain Query Agent for MOSDAC Knowledge Graph
Bharatiya Antariksh Hackathon 2025 - Problem Statement 2 - Phase 2

This agent:
1. Converts natural language queries into Cypher
2. Queries Neo4j and processes responses
3. Uses Gemini Pro 1.5 for fallback responses
4. Provides intelligent conversational interface
"""

import os
import json
import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from datetime import datetime

# LangChain imports
from langchain.agents import AgentExecutor, create_react_agent
from langchain.tools import Tool
from langchain.prompts import PromptTemplate
from langchain.schema import BaseOutputParser
from langchain.memory import ConversationBufferMemory
from langchain_core.messages import HumanMessage, AIMessage

# Neo4j LangChain integration
from langchain_community.graphs import Neo4jGraph
from langchain.chains import GraphCypherQAChain

# Gemini API
try:
    import google.generativeai as genai
except ImportError:
    raise ImportError(
        """The package 'google-generativeai' is not installed in your current Python environment.\n"
        "Please install it with: pip install google-generativeai\n"
        "And make sure you run Streamlit with the same Python environment, e.g.:\n"
        "    python -m streamlit run app.py\n"
    )
from langchain_google_genai import ChatGoogleGenerativeAI

# Environment variables
from dotenv import load_dotenv
load_dotenv()

# Other imports
import re
from neo4j import GraphDatabase

class CypherQueryGenerator:
    """
    Generates Cypher queries from natural language using templates and patterns
    """
    
    def __init__(self):
        self.query_templates = {
            'find_satellite': {
                'patterns': [
                    r'(?:which|what|find|list).*satellite.*(?:monitor|observe|track).*(\w+)',
                    r'satellite.*(?:for|that).*(\w+)',
                    r'(\w+).*satellite'
                ],
                'template': """
                    MATCH (s:Satellite)-[r:MONITORS|OBSERVES|TRACKS]->(target)
                    WHERE target.name CONTAINS '{entity}' OR s.name CONTAINS '{entity}'
                    RETURN s.name, type(r), target.name, r.confidence
                    ORDER BY r.confidence DESC
                    LIMIT 10
                """
            },
            
            'find_sensor': {
                'patterns': [
                    r'(?:which|what|find|list).*sensor.*(?:on|aboard|in).*(\w+)',
                    r'sensor.*(?:of|from).*(\w+)',
                    r'(\w+).*sensor'
                ],
                'template': """
                    MATCH (sensor:Sensor)-[r:INSTALLED_ON]->(satellite:Satellite)
                    WHERE satellite.name CONTAINS '{entity}' OR sensor.name CONTAINS '{entity}'
                    RETURN sensor.name, satellite.name, r.confidence
                    ORDER BY r.confidence DESC
                    LIMIT 10
                """
            },
            
            'find_products': {
                'patterns': [
                    r'(?:which|what|find|list).*product.*(?:from|generated by|by).*(\w+)',
                    r'product.*(?:of|from).*(\w+)',
                    r'(\w+).*product'
                ],
                'template': """
                    MATCH (source)-[r:GENERATES|PROVIDES]->(product:Product)
                    WHERE source.name CONTAINS '{entity}' OR product.name CONTAINS '{entity}'
                    RETURN source.name, product.name, type(r), r.confidence
                    ORDER BY r.confidence DESC
                    LIMIT 10
                """
            },
            
            'find_relationships': {
                'patterns': [
                    r'relationship.*between.*(\w+).*and.*(\w+)',
                    r'how.*(\w+).*(?:relate|connect).*(\w+)',
                    r'connection.*(\w+).*(\w+)'
                ],
                'template': """
                    MATCH (a:Entity)-[r]-(b:Entity)
                    WHERE a.name CONTAINS '{entity1}' AND b.name CONTAINS '{entity2}'
                    RETURN a.name, type(r), b.name, r.confidence
                    ORDER BY r.confidence DESC
                    LIMIT 10
                """
            },
            
            'find_entity_info': {
                'patterns': [
                    r'(?:what is|tell me about|information about|describe).*(\w+)',
                    r'(\w+).*(?:description|info|details)'
                ],
                'template': """
                    MATCH (e:Entity)-[r]-(related)
                    WHERE e.name CONTAINS '{entity}'
                    RETURN e.name, e.type, collect(DISTINCT related.name) as related_entities,
                           collect(DISTINCT type(r)) as relationships
                    LIMIT 5
                """
            },
            
            'list_all': {
                'patterns': [
                    r'(?:list all|show all|all).*(\w+)',
                    r'(\w+).*(?:list|available)'
                ],
                'template': """
                    MATCH (n:{entity_type})
                    RETURN n.name, n.confidence
                    ORDER BY n.confidence DESC
                    LIMIT 15
                """
            }
        }
    
    def extract_entities_from_query(self, query: str) -> List[str]:
        """Extract potential entities from the query"""
        # Simple entity extraction - could be improved with NER
        words = re.findall(r'\b[A-Z][a-z]+(?:\-[A-Z][a-z]+)*\b', query)
        return words
    
    def generate_cypher(self, natural_query: str) -> Optional[Tuple[str, str]]:
        """
        Generate Cypher query from natural language
        
        Args:
            natural_query: Natural language query
            
        Returns:
            Tuple of (cypher_query, query_type) or None
        """
        query_lower = natural_query.lower()
        
        for query_type, template_info in self.query_templates.items():
            for pattern in template_info['patterns']:
                match = re.search(pattern, query_lower)
                if match:
                    entities = match.groups()
                    
                    if query_type == 'list_all' and entities:
                        # Special handling for list_all queries
                        entity_type = entities[0].title()
                        if entity_type.endswith('s'):
                            entity_type = entity_type[:-1]  # Remove plural
                        
                        cypher = template_info['template'].format(entity_type=entity_type)
                    elif len(entities) == 1:
                        cypher = template_info['template'].format(entity=entities[0])
                    elif len(entities) == 2:
                        cypher = template_info['template'].format(
                            entity1=entities[0], entity2=entities[1]
                        )
                    else:
                        continue
                    
                    return cypher, query_type
        
        return None


class MOSDACQueryAgent:
    """
    Main query agent that combines Neo4j querying with Gemini LLM
    """
    
    def __init__(self, neo4j_uri: str = "", neo4j_user: str = "", 
                 neo4j_password: str = "", gemini_api_key: str = ""):
        """
        Initialize the query agent
        
        Args:
            neo4j_uri: Neo4j database URI
            neo4j_user: Neo4j username
            neo4j_password: Neo4j password
            gemini_api_key: Gemini API key
        """
        # Setup logging
        self.setup_logging()
        
        # Get credentials from environment if not provided
        self.neo4j_uri = neo4j_uri or os.getenv('NEO4J_URI')
        self.neo4j_user = neo4j_user or os.getenv('NEO4J_USER')
        self.neo4j_password = neo4j_password or os.getenv('NEO4J_PASSWORD')
        self.gemini_api_key = gemini_api_key or os.getenv('GEMINI_API_KEY')
        
        # Initialize components
        self.cypher_generator = CypherQueryGenerator()
        self.graph = None
        self.gemini_llm = None
        self.memory = ConversationBufferMemory(
            memory_key="chat_history",
            return_messages=True
        )
        
        # Initialize connections
        self.setup_neo4j_connection()
        self.setup_gemini_connection()
        
        # Query statistics
        self.query_stats = {
            'total_queries': 0,
            'neo4j_queries': 0,
            'gemini_queries': 0,
            'failed_queries': 0
        }
        
        self.logger.info("MOSDAC Query Agent initialized successfully")
    
    def setup_logging(self):
        """Setup logging for query agent"""
        output_dir = Path("mosdac_data")
        log_file = output_dir / "logs" / "query_agent.log"
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler()
            ]
        )
        
        self.logger = logging.getLogger(__name__)
    
    def setup_neo4j_connection(self):
        """Setup Neo4j graph connection"""
        try:
            self.graph = Neo4jGraph(
                url=self.neo4j_uri or "",
                username=self.neo4j_user or "",
                password=self.neo4j_password or ""
            )
            
            # Test connection
            result = self.graph.query("RETURN 1 as test")
            if result:
                self.logger.info("Neo4j connection established successfully")
            else:
                raise Exception("Neo4j connection test failed")
                
        except Exception as e:
            self.logger.error(f"Failed to connect to Neo4j: {e}")
            self.graph = None
    
    def setup_gemini_connection(self):
        """Setup Gemini LLM connection"""
        try:
            if not self.gemini_api_key:
                raise ValueError("Gemini API key not provided")
            
            try:
                genai.configure(api_key=self.gemini_api_key)  # type: ignore
            except Exception:
                pass
            
            # Initialize Gemini LLM
            self.gemini_llm = ChatGoogleGenerativeAI(
                model="gemini-1.5-pro",
                api_key=self.gemini_api_key,  # type: ignore
                temperature=0.1
            )
            
            # Test Gemini connection
            test_response = self.gemini_llm.invoke("Hello")
            if test_response:
                self.logger.info("Gemini connection established successfully")
            else:
                raise Exception("Gemini connection test failed")
                
        except Exception as e:
            self.logger.error(f"Failed to connect to Gemini: {e}")
            self.gemini_llm = None
    
    def query_neo4j(self, cypher_query: str) -> Optional[List[Dict]]:
        """
        Execute Cypher query against Neo4j
        
        Args:
            cypher_query: Cypher query to execute
            
        Returns:
            Query results or None if failed
        """
        if not self.graph:
            self.logger.error("Neo4j connection not available")
            return None
        
        try:
            self.logger.info(f"Executing Cypher query: {cypher_query}")
            results = self.graph.query(cypher_query)  # type: ignore
            self.query_stats['neo4j_queries'] += 1
            return results
            
        except Exception as e:
            self.logger.error(f"Neo4j query failed: {e}")
            return None
    
    def query_gemini(self, question: str, context: str = "") -> Optional[str]:
        """
        Query Gemini LLM for fallback responses
        
        Args:
            question: User's question
            context: Additional context from Neo4j
            
        Returns:
            Gemini response or None if failed
        """
        if not self.gemini_llm:
            self.logger.error("Gemini connection not available")
            return None
        
        try:
            # Create enhanced prompt
            prompt = f"""
You are an expert assistant for the MOSDAC (Meteorological & Oceanographic Satellite Data Archival Centre) system.

Context from Knowledge Graph: {context}

User Question: {question}

Please provide a helpful, accurate response about satellite data, meteorological observations, 
sensors, missions, or related topics. If the context doesn't contain enough information, 
use your knowledge about satellite meteorology and ISRO missions.

Keep your response informative but concise.
"""
            
            response = self.gemini_llm.invoke(prompt)
            self.query_stats['gemini_queries'] += 1
            
            if hasattr(response, 'content'):
                return str(response.content)
            elif isinstance(response, str):
                return response
            elif isinstance(response, list):
                return str(response)
            else:
                return None
            
        except Exception as e:
            self.logger.error(f"Gemini query failed: {e}")
            return None
    
    def format_neo4j_results(self, results: List[Dict], query_type: str) -> str:
        """
        Format Neo4j results into human-readable text
        
        Args:
            results: Query results from Neo4j
            query_type: Type of query executed
            
        Returns:
            Formatted response string
        """
        if not results:
            return "No results found in the knowledge graph."
        
        if query_type == 'find_satellite':
            response = "ðŸ›°ï¸ **Satellites found:**\n"
            for result in results:
                satellite = result.get('s.name', 'Unknown')
                relationship = result.get('type(r)', 'related to')
                target = result.get('target.name', 'Unknown')
                confidence = result.get('r.confidence', 0)
                response += f"â€¢ **{satellite}** {relationship} **{target}** (confidence: {confidence:.2f})\n"
        
        elif query_type == 'find_sensor':
            response = "ðŸ” **Sensors found:**\n"
            for result in results:
                sensor = result.get('sensor.name', 'Unknown')
                satellite = result.get('satellite.name', 'Unknown')
                confidence = result.get('r.confidence', 0)
                response += f"â€¢ **{sensor}** installed on **{satellite}** (confidence: {confidence:.2f})\n"
        
        elif query_type == 'find_products':
            response = "ðŸ“Š **Products found:**\n"
            for result in results:
                source = result.get('source.name', 'Unknown')
                product = result.get('product.name', 'Unknown')
                relationship = result.get('type(r)', 'generates')
                confidence = result.get('r.confidence', 0)
                response += f"â€¢ **{source}** {relationship} **{product}** (confidence: {confidence:.2f})\n"
        
        elif query_type == 'find_relationships':
            response = "ðŸ”— **Relationships found:**\n"
            for result in results:
                entity1 = result.get('a.name', 'Unknown')
                relationship = result.get('type(r)', 'related to')
                entity2 = result.get('b.name', 'Unknown')
                confidence = result.get('r.confidence', 0)
                response += f"â€¢ **{entity1}** {relationship} **{entity2}** (confidence: {confidence:.2f})\n"
        
        elif query_type == 'find_entity_info':
            response = "â„¹ï¸ **Entity information:**\n"
            for result in results:
                entity = result.get('e.name', 'Unknown')
                entity_type = result.get('e.type', 'Unknown')
                related = result.get('related_entities', [])
                relationships = result.get('relationships', [])
                
                response += f"â€¢ **{entity}** (Type: {entity_type})\n"
                if related:
                    response += f"  - Related entities: {', '.join(related[:5])}\n"
                if relationships:
                    response += f"  - Relationships: {', '.join(set(relationships[:5]))}\n"
        
        elif query_type == 'list_all':
            response = "ðŸ“‹ **Complete list:**\n"
            for result in results:
                name = result.get('n.name', 'Unknown')
                confidence = result.get('n.confidence', 0)
                response += f"â€¢ **{name}** (confidence: {confidence:.2f})\n"
        
        else:
            # Generic formatting
            response = "ðŸ“‹ **Results:**\n"
            for i, result in enumerate(results[:10]):  # Limit to 10 results
                response += f"{i+1}. {result}\n"
        
        return response
    
    def process_query(self, user_query: str) -> Dict[str, Any]:
        """
        Process user query through both Neo4j and Gemini
        
        Args:
            user_query: Natural language query from user
            
        Returns:
            Dictionary containing response and metadata
        """
        self.query_stats['total_queries'] += 1
        
        response_data = {
            'user_query': user_query,
            'timestamp': datetime.now().isoformat(),
            'neo4j_response': None,
            'gemini_response': None,
            'cypher_query': None,
            'query_type': None,
            'source': None,
            'confidence': 0.0
        }
        
        # Try Neo4j first
        cypher_result = self.cypher_generator.generate_cypher(user_query)
        if cypher_result:
            cypher_query, query_type = cypher_result
            response_data['cypher_query'] = cypher_query
            response_data['query_type'] = query_type
            
            neo4j_results = self.query_neo4j(cypher_query)
            
            if neo4j_results:
                formatted_response = self.format_neo4j_results(neo4j_results, query_type)
                response_data['neo4j_response'] = formatted_response
                response_data['source'] = 'neo4j'
                response_data['confidence'] = 0.9
                
                # Add context for Gemini
                context = f"Knowledge Graph Results: {formatted_response}"
            else:
                context = "No results found in knowledge graph."
        else:
            context = "Query could not be converted to database query."
        
        # Use Gemini for enhanced response or fallback
        gemini_response = self.query_gemini(user_query, context)
        if gemini_response:
            response_data['gemini_response'] = gemini_response
            if not response_data['source']:
                response_data['source'] = 'gemini'
                response_data['confidence'] = 0.7
        
        # Handle failure case
        if not response_data['neo4j_response'] and not response_data['gemini_response']:
            response_data['gemini_response'] = "I'm sorry, I couldn't find information about that. Please try rephrasing your question or ask about satellites, sensors, missions, or meteorological data."
            response_data['source'] = 'fallback'
            response_data['confidence'] = 0.1
            self.query_stats['failed_queries'] += 1
        
        # Store in memory
        self.memory.chat_memory.add_user_message(user_query)
        final_response = response_data['neo4j_response'] or response_data['gemini_response']
        self.memory.chat_memory.add_ai_message(final_response)
        
        return response_data
    
    def get_query_statistics(self) -> Dict[str, Any]:
        """Get query statistics"""
        return {
            **self.query_stats,
            'success_rate': (self.query_stats['total_queries'] - self.query_stats['failed_queries']) / max(1, self.query_stats['total_queries']),
            'neo4j_success_rate': self.query_stats['neo4j_queries'] / max(1, self.query_stats['total_queries']),
            'gemini_usage_rate': self.query_stats['gemini_queries'] / max(1, self.query_stats['total_queries'])
        }
    
    def get_sample_questions(self) -> List[str]:
        """Get sample questions for users to try"""
        return [
            "Which satellite monitors tropical rainfall?",
            "What sensors are on INSAT-3D?",
            "List all products from SAPHIR sensor",
            "Tell me about Megha-Tropiques mission",
            "What is the relationship between INSAT and meteorological data?",
            "Which satellites observe ocean temperature?",
            "What products does MOSDAC provide?",
            "List all available satellites",
            "How does VHRR relate to weather monitoring?",
            "What data products are generated by IMAGER sensor?"
        ]
    
    def export_conversation(self, filename: Optional[str] = None) -> str:
        """Export conversation history"""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"mosdac_data/logs/conversation_{timestamp}.json"
        filename = filename or "conversation.json"
        
        conversation_data = {
            'exported_at': datetime.now().isoformat(),
            'query_statistics': self.get_query_statistics(),
            'conversation_history': []
        }
        
        # Extract conversation from memory
        messages = self.memory.chat_memory.messages
        for i in range(0, len(messages), 2):
            if i + 1 < len(messages):
                conversation_data['conversation_history'].append({
                    'user': messages[i].content,
                    'assistant': messages[i + 1].content,
                    'timestamp': datetime.now().isoformat()
                })
        
        with open(filename, 'w', encoding='utf-8') as f:  # type: ignore
            json.dump(conversation_data, f, ensure_ascii=False, indent=2)
        
        return filename


class MOSDACChatInterface:
    """
    Simple chat interface for testing the query agent
    """
    
    def __init__(self, agent: MOSDACQueryAgent):
        self.agent = agent
    
    def start_chat(self):
        """Start interactive chat session"""
        print("ðŸ›°ï¸ MOSDAC Knowledge Graph Chat Interface")
        print("=" * 60)
        print("Ask me anything about satellites, sensors, missions, or meteorological data!")
        print("Type 'exit' to quit, 'stats' for statistics, 'samples' for sample questions")
        print("=" * 60)
        
        while True:
            try:
                user_input = input("\nðŸ¤” You: ").strip()
                
                if user_input.lower() in ['exit', 'quit', 'bye']:
                    print("\nðŸ‘‹ Goodbye! Thanks for using MOSDAC Chat!")
                    # Export conversation
                    filename = self.agent.export_conversation()
                    print(f"ðŸ’¾ Conversation saved to: {filename}")
                    break
                
                elif user_input.lower() == 'stats':
                    stats = self.agent.get_query_statistics()
                    print(f"\nðŸ“Š Query Statistics:")
                    for key, value in stats.items():
                        print(f"  - {key}: {value}")
                    continue
                
                elif user_input.lower() == 'samples':
                    samples = self.agent.get_sample_questions()
                    print(f"\nðŸ’¡ Sample questions to try:")
                    for i, question in enumerate(samples, 1):
                        print(f"  {i}. {question}")
                    continue
                
                elif not user_input:
                    continue
                
                # Process query
                print("\nðŸ¤– Processing your query...")
                response_data = self.agent.process_query(user_input)
                
                # Display response
                print(f"\nðŸ¤– Assistant: {response_data['neo4j_response'] or response_data['gemini_response']}")
                
                # Show metadata
                print(f"\nðŸ“‹ Query Details:")
                print(f"  - Source: {response_data['source']}")
                print(f"  - Confidence: {response_data['confidence']:.2f}")
                if response_data['cypher_query']:
                    print(f"  - Cypher: {response_data['cypher_query'][:100]}...")
                
            except KeyboardInterrupt:
                print("\n\nðŸ‘‹ Chat interrupted. Goodbye!")
                break
            except Exception as e:
                print(f"\nâŒ Error: {e}")
                continue


def setup_credentials():
    """Setup required API credentials"""
    print("ðŸ” Credentials Setup")
    print("=" * 30)
    
    # Check existing credentials
    neo4j_uri = os.getenv('NEO4J_URI')
    neo4j_user = os.getenv('NEO4J_USER')
    neo4j_password = os.getenv('NEO4J_PASSWORD')
    gemini_key = os.getenv('GEMINI_API_KEY')
    
    missing_creds = []
    
    if not neo4j_uri:
        missing_creds.append('NEO4J_URI')
    if not neo4j_user:
        missing_creds.append('NEO4J_USER')
    if not neo4j_password:
        missing_creds.append('NEO4J_PASSWORD')
    if not gemini_key:
        missing_creds.append('GEMINI_API_KEY')
    
    if missing_creds:
        print(f"âš ï¸ Missing credentials: {', '.join(missing_creds)}")
        print("\nPlease add these to your .env file:")
        print("NEO4J_URI=bolt://xxxxx.databases.neo4j.io:7687")
        print("NEO4J_USER=neo4j")
        print("NEO4J_PASSWORD=your_password")
        print("GEMINI_API_KEY=your_gemini_api_key")
        print("\nGet Gemini API key from: https://aistudio.google.com/app/apikey")
        return False
    
    print("âœ… All credentials found!")
    return True


def main():
    """
    Main function to run the query agent
    """
    print("ðŸ¤– MOSDAC LangChain Query Agent")
    print("=" * 50)
    print("Intelligent conversational interface for MOSDAC Knowledge Graph")
    print("=" * 50)
    
    # Setup credentials
    if not setup_credentials():
        return
    
    try:
        # Initialize query agent
        print("ðŸš€ Initializing query agent...")
        agent = MOSDACQueryAgent()
        
        # Start chat interface
        chat_interface = MOSDACChatInterface(agent)
        chat_interface.start_chat()
        
    except Exception as e:
        print(f"\nâŒ Query agent failed to start: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()